name: DeadRemote v0.2.12

slots:
    core:
        class: CoreUnit
    db:
        class: DataBank
        select: manual
    antigrav:
        class: AntiGravityGeneratorUnit
    warpdrive:
        class: WarpDriveUnit
    atmofueltank:
        class: AtmoFuelContainer
        select: all
    spacefueltank:
        class: SpaceFuelContainer
        select: all
    rocketfueltank:
        class: RocketFuelContainer
        select: all
    gyro:
        class: GyroUnit
    radar:
        class: RadarPVPUnit
        select: manual
    shield:
        class: ShieldGeneratorUnit
        select: manual

handlers:
  unit:
    onStart:
      lua: |
        ------- Predifined Engine Tags -------
        predefinedTags = {}
        table.insert(predefinedTags,'military')
        table.insert(predefinedTags,'maneuver')
        table.insert(predefinedTags,'freight')
        ---------------------------------------
        hudVersion = 'v0.2.2'
        useDB = false --export
        showRemotePanel = false --export
        showDockingPanel = false --export
        showFuelPanel = false --export
        showHelper = false --export
        showShieldWidget = false --export
        defaultHoverHeight = 42 --export
        defautlFollowDistance = 40 --export
        topHUDLineColorSZ = 'white' --export
        topHUDFillColorSZ = 'rgba(29, 63, 255, 0.75)' --export
        textColorSZ = 'white' --export
        topHUDLineColorPVP = 'lightgrey' --export
        topHUDFillColorPVP = 'rgba(255, 0, 0, 0.75)' --export
        textColorPVP = 'black' --export
        fuelTextColor = 'white' --export
        Indicator_Width = 1.5
        Direction_Indicator_Size = 5 --export
        Direction_Indicator_Color = 'white' --export
        Prograde_Indicator_Size = 7.5 --export
        Prograde_Indicator_Color = 'rgb(60, 255, 60)' --export
        AP_Brake_Buffer = 5000 --export
        AP_Max_Rotation_Factor = 20 --export
        AR_Mode = 'NONE' --export
        AR_Range = 3 --export
        AR_Size = 15 --export
        AR_Fill = 'rgb(29, 63, 255)' --export
        AR_Outline = 'white' --export
        AR_Opacity = '0.5' --export
        AR_Exclude_Moons = true --export
        EngineTagColor = 'rgb(60, 255, 60)' --export
        initialResistWait = 15
        autoVent = true
        ------------------------------------
        
        if db_1 ~= nil and useDB then
            globalDB('get')
        end
        
        followID = nil
        AR_Custom_Points = {}
        AR_Custom = false
        AR_Temp = false
        AR_Temp_Points = {}
        if pcall(require,'autoconf/custom/AR_Waypoints') then 
            waypoints = require('autoconf/custom/AR_Waypoints') 
            for name,pos in pairs(waypoints) do
                AR_Custom_Points[name] = pos
                AR_Custom = true
            end
        end
        screenHeight = system.getScreenHeight()
        screenWidth = system.getScreenWidth()
        maxFuel = 0
        for i,v in pairs(spacefueltank) do maxFuel = maxFuel + v.getMaxVolume() end
        currentSystem = Atlas[0]
        planets = {}
        constructPosition = vec3(construct.getWorldPosition())
        warp_beacons = {}
        if pcall(require,'autoconf/custom/beacons') then 
            beacons = require('autoconf/custom/beacons') 
            for name,pos in pairs(beacons) do
                warp_beacons[name] = convertWaypoint(pos)
            end
        end
        for k,v in pairs(currentSystem) do 
            warp_beacons[currentSystem[k]['name'][1]] = vec3(currentSystem[k]['center']) 
            planets[currentSystem[k]['name'][1]] = vec3(currentSystem[k]['center']) 
        end
        pipes = {}
        SZ = vec3(13771471, 7435803, -128971)
        inSZ = true
        enabledEngineTags = {}
        ------------------------------------
        
        pitchInput = 0
        rollInput = 0
        yawInput = 0
        brakeInput = 0
        
        Nav = Navigator.new(system, core, unit)
        Nav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})
        Nav.axisCommandManager:setTargetGroundAltitude(0)
        
        -- Parenting widget
        if showDockingPanel then
            parentingPanelId = system.createWidgetPanel("Docking")
            parentingWidgetId = system.createWidget(parentingPanelId,"parenting")
            system.addDataToWidget(unit.getDataId(),parentingWidgetId)
        end
        
        
        -- element widgets
        -- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.
        if not showRemotePanel then
            unit.hideWidget()
            core.hideWidget()
        else
            unit.showWidget()
            core.showWidget()
        end
        
        placeRadar = true
        if atmofueltank_size > 0 and showFuelPanel then
            _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, "Atmo Fuel", "fuel_container")
            if placeRadar then
                _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                placeRadar = false
            end
        end
        if spacefueltank_size > 0 and showFuelPanel then
            _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, "Space Fuel", "fuel_container")
            if placeRadar then
                _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
                placeRadar = false
            end
        end
        _autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, "Rocket Fuel", "fuel_container")
        if placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels
            _autoconf.displayCategoryPanel(radar, radar_size, "Radar", "radar")
            placeRadar = false
        end
        if antigrav ~= nil then antigrav.show() end
        if warpdrive ~= nil then warpdrive.show() end
        if gyro ~= nil then gyro.show() end
        if shield_1 ~= nil and showShieldWidget then shield_1.show() end
        
        -- freeze the player in he is remote controlling the construct
        seated = player.isSeated()
        if seated == 1 then
            player.freeze(1)
        end
        
        if not showHelper then
            system.showHelper(0)
        end
        
        -- landing gear
        -- make sure every gears are synchonized with the first
        gearExtended = (Nav.control.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean
        if gearExtended then
            Nav.control.deployLandingGears()
        else
            Nav.control.retractLandingGears()
        end
        
        if vec3(construct.getWorldVelocity()):len() * 3.6 < 500 then
            brakeInput = brakeInput + 1
        end
        
        lShift = false
        
        system.showScreen(1)
    onStop:
      lua: |
        _autoconf.hideCategoryPanels()
        if antigrav ~= nil then antigrav.hideWidget() end
        if warpdrive ~= nil then warpdrive.hideWidget() end
        if gyro ~= nil then gyro.hideWidget() end
        core.hideWidget()
        Nav.control.switchOffHeadlights()
        globalDB('save')
  system:
    onStart:
      lua: |
        json = require("dkjson")
        Atlas = require('atlas')
        
        
        function convertWaypoint(wp)
            local clamp  = utils.clamp
            local deg2rad    = math.pi/180
            local rad2deg    = 180/math.pi
            local epsilon    = 1e-10
        
            local num        = ' *([+-]?%d+%.?%d*e?[+-]?%d*)'
            local posPattern = '::pos{' .. num .. ',' .. num .. ',' ..  num .. ',' .. num ..  ',' .. num .. '}'
            local systemId = wp 
        
            systemId, bodyId, latitude, longitude, altitude = string.match(wp, posPattern)
            assert(systemId, 'Position string is malformed.')
        
            systemId  = tonumber(systemId)
            bodyId    = tonumber(bodyId)
            latitude  = tonumber(latitude)
            longitude = tonumber(longitude)
            altitude  = tonumber(altitude)
        
            if bodyId == 0 then -- this is a hack to represent points in space
            mapPosition =  setmetatable({latitude  = latitude,
                                        longitude = longitude,
                                        altitude  = altitude,
                                        bodyId    = bodyId,
                                        systemId  = systemId}, MapPosition)
            else
            mapPosition = setmetatable({latitude  = deg2rad*clamp(latitude, -90, 90),
                                        longitude = deg2rad*(longitude % 360),
                                        altitude  = altitude,
                                        bodyId    = bodyId,
                                        systemId  = systemId}, MapPosition)
            end
            if mapPosition.bodyId == 0 then
                return vec3(mapPosition.latitude, mapPosition.longitude, mapPosition.altitude)
            end
        
            local center = {
                x=Atlas[systemId][bodyId].center[1],
                y=Atlas[systemId][bodyId].center[2],
                z=Atlas[systemId][bodyId].center[3]
            }
        
            local xproj = math.cos(mapPosition.latitude)
            return center + (Atlas[systemId][bodyId].radius + mapPosition.altitude) *
                vec3(xproj*math.cos(mapPosition.longitude),
                    xproj*math.sin(mapPosition.longitude),
                    math.sin(mapPosition.latitude))
        end
        
        function string.starts(String,Start)
           return string.sub(String,1,string.len(Start))==Start
        end
        
        function pipeDist(A,B,loc,reachable)
            local AB = vec3.new(B['x']-A['x'],B['y']-A['y'],B['z']-A['z'])
            local BE = vec3.new(loc['x']-B['x'],loc['y']-B['y'],loc['z']-B['z'])
            local AE = vec3.new(loc['x']-A['x'],loc['y']-A['y'],loc['z']-A['z'])
        
            -- Is the point within warp distance and do we care?
            if AB:len() <= 500/0.000005 or not reachable then
                AB_BE = AB:dot(BE)
                AB_AE = AB:dot(AE)
        
                -- Is the point past the warp destination?
                -- If so, then the warp destination is closest
                if (AB_BE > 0) then
                    dist = BE:len()
                    distType = 'POINT'
        
                -- Is the point before the start point?
                -- If so, then the start point is the closest
                elseif (AB_AE < 0) then
                    dist = AE:len()
                    distType = 'POINT'
        
                -- If neither above condition was met, then the
                -- destination point must have be directly out from
                -- somewhere along the warp pipe. Let's calculate
                -- that distance
                else
                    dist = vec3(AE:cross(BE)):len()/vec3(AB):len()
                    distType = 'PIPE'
                end
                return dist,distType
            end
            return nil,nil
        end
        
        function closestPlanet()
            local cName = nil
            local cDist = nil
            for pname,pvec in pairs(planets) do
                local tempDist = vec3(constructPosition-pvec):len()
                if cDist == nil or cDist > tempDist then
                    cDist = tempDist
                    cName = pname
                end
            end
            return cName,cDist
        end
        
        function closestPipe()
            pipes = {}
            for name,center in pairs(planets) do
                    pipes[string.format('%s - %s',closestPlanetName,name)] = {}
                    table.insert(pipes[string.format('%s - %s',closestPlanetName,name)],planets[closestPlanetName])
                    table.insert(pipes[string.format('%s - %s',closestPlanetName,name)],center)
            end
            local cPipe = 'None'
            local cDist = 9999999999
            local cLoc = vec3(construct.getWorldPosition())
            for pName,vecs in pairs(pipes) do
                local tempDist,tempType = pipeDist(vecs[1],vecs[2],cLoc,false)
                if tempDist ~= nil then
                    if cDist > tempDist then
                        cDist = tempDist
                        cPipe = pName
                    end
                end
            end
            return cPipe,cDist
        end
        
        function contains(tablelist, val)
            for i=1,#tablelist do
               if tablelist[i] == val then 
                  return true
               end
            end
            return false
         end
        
        
         function WeaponWidgetCreate()
            if type(weapon) == 'table' and #weapon > 0 then
                local WeaponPanaelIdList = {}
                for i = 1, #weapon do
                    if i%2 ~= 0 then
                    table.insert(WeaponPanaelIdList, system.createWidgetPanel(''))
                    end
                        local WeaponWidgetDataId = weapon[i].getDataId()
                        local WeaponWidgetType = weapon[i].getWidgetType()
                        system.addDataToWidget(WeaponWidgetDataId, system.createWidget(WeaponPanaelIdList[#WeaponPanaelIdList], WeaponWidgetType))
                end
            end
        end
        
        function brakeWidget()
            local brakeON = brakeInput > 0
            local bw = ''
            if brakeON then
                bw = [[
                    <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                        <rect x="46vw" y="28vh" rx="10" ry="10" width="7vw" height="3vh" style="fill:rgba(29, 63, 255, 0.9);stroke:rgba(255, 60, 60, 0.9);stroke-width:5;" />
                        <text x="]].. tostring(.47 * screenWidth) ..[[" y="]].. tostring(.30 * screenHeight) ..[[" style="fill: rgb(255, 60, 60)" font-size=".8vw" font-weight="bold">Brakes Engaged</text>
                    </svg>
                ]]
            end
            return bw
        end
        
        function flightWidget()
            if Nav.axisCommandManager:getMasterMode() == controlMasterModeId.travel then mode = 'Throttle ' .. tostring(Nav.axisCommandManager:getThrottleCommand(0) * 100) .. '%' modeBG = bgColor
            else mode = 'Cruise '  .. string.format('%.2f',Nav.axisCommandManager:getTargetSpeed(0)) .. ' km/h' modeBG = 'rgba(99, 250, 79, 0.5)'
            end
            local sw = ''
            if maxBrakeStr ~= nil then
                --Center Top
                sw = [[
                    <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                        <path d="
                        M ]] .. tostring(.31*screenWidth) .. ' ' .. tostring(.001*screenHeight) ..[[ 
                        L ]] .. tostring(.69*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                        L ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[
                        L ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[
                        L ]] .. tostring(.31*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [["
                        stroke="]]..lineColor..[[" stroke-width="2" fill="]]..bgColor..[[" />]]
                
        
                -- Right Side
                sw = sw .. [[<path d="
                        M ]] .. tostring(.6635*screenWidth) .. ' ' .. tostring(.028*screenHeight) .. [[ 
                        L ]] .. tostring(.691*screenWidth) .. ' ' .. tostring(.0387*screenHeight) .. [[
                        L ]] .. tostring(.80*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                        L ]] .. tostring(.69*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                        L ]] .. tostring(.6635*screenWidth) .. ' ' .. tostring(.0185*screenHeight) .. [[
                        L ]] .. tostring(.6635*screenWidth) .. ' ' .. tostring(.028*screenHeight) .. [["
                        stroke="]]..lineColor..[[" stroke-width="1" fill="]].. modeBG ..[[" />]]
                        
                sw = sw .. [[<path d="
                        M ]] .. tostring(.5*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[ 
                        L ]] .. tostring(.5*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [["
                        stroke="]]..lineColor..[[" stroke-width="1" fill="none" />
        
                        <path d="
                        M ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[ 
                        L ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [["
                        stroke="]]..lineColor..[[" stroke-width="1" fill="none" />
        
                        <path d="
                        M ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[ 
                        L ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [["
                        stroke="]]..lineColor..[[" stroke-width="1" fill="none" />
        
                        <text x="]].. tostring(.4 * screenWidth) ..[[" y="]].. tostring(.015 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Speed: ]] .. speedStr .. [[</text>
                        <text x="]].. tostring(.4 * screenWidth) ..[[" y="]].. tostring(.0325 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Current Accel: ]] .. accelStr .. [[</text>
                        <text x="]].. tostring(.4 * screenWidth) ..[[" y="]].. tostring(.05 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Brake Dist: ]] .. brakeDistStr .. [[</text>
                        
                        <text x="]].. tostring(.502 * screenWidth) ..[[" y="]].. tostring(.015 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Max Speed: ]] .. maxSpeedStr .. [[</text>
                        <text x="]].. tostring(.502 * screenWidth) ..[[" y="]].. tostring(.0325 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Max Accel: ]] .. maxThrustStr ..[[</text>
                        <text x="]].. tostring(.502 * screenWidth) ..[[" y="]].. tostring(.05 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Max Brake: ]] .. maxBrakeStr .. [[</text>
        
                        <text x="]].. tostring(.37 * screenWidth) ..[[" y="]].. tostring(.015 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Mass </text>
                        <text x="]].. tostring(.355 * screenWidth) ..[[" y="]].. tostring(.028 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">]]..massStr..[[</text>
        
                        <text x="]].. tostring(.612 * screenWidth) ..[[" y="]].. tostring(.015 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Gravity </text>
                        <text x="]].. tostring(.612 * screenWidth) ..[[" y="]].. tostring(.028 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">]].. gravityStr ..[[</text>
        
                        <text x="]].. tostring(.684 * screenWidth) ..[[" y="]].. tostring(.028 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold" transform="rotate(-10,]].. tostring(.684 * screenWidth) ..",".. tostring(.028 * screenHeight) ..[[)">]].. mode ..[[</text>
        
                        
        
                    </svg>
                    ]]
            else
                sw = ''
            end
            return sw
        end
        
        function fuelWidget()
            curFuel = 0
            local fuelWarning = false
            local fuelTankWarning = false
            for i,v in pairs(spacefueltank) do 
                curFuel = curFuel + v.getItemsVolume()
                if v.getItemsVolume()/v.getMaxVolume() < .2 then fuelTankWarning = true end
            end
            sFuelPercent = curFuel/maxFuel * 100
            if sFuelPercent < 20 then fuelWarning = true end
            curFuelStr = string.format('%.2f%%',sFuelPercent)
        
            --Center bottom ribbon
            local fw = string.format([[
                <svg width="100%%" height="100%%" style="position: absolute;left:0%%;top:0%%;font-family: Calibri;">
                    <linearGradient id="sFuel" x1="0%%" y1="0%%" x2="100%%" y2="0%%">
                    <stop offset="%.1f%%" style="stop-color:rgba(99, 250, 79, 0.95);stop-opacity:.95" />
                    <stop offset="%.1f%%" style="stop-color:rgba(255, 10, 10, 0.5);stop-opacity:.5" />
                    </linearGradient>]],sFuelPercent,sFuelPercent)
                
            fw = fw .. [[
                <path d="
                M ]] .. tostring(.336*screenWidth) .. ' ' .. tostring(.0185*screenHeight) .. [[ 
                L ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[
                L ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[
                L ]] .. tostring(.6635*screenWidth) .. ' ' .. tostring(.0185*screenHeight) .. [[
                L ]] .. tostring(.6635*screenWidth) .. ' ' .. tostring(.028*screenHeight) .. [[
                L ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [[
                L ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [[
                L ]] .. tostring(.3365*screenWidth) .. ' ' .. tostring(.028*screenHeight) .. [[
                L ]] .. tostring(.336*screenWidth) .. ' ' .. tostring(.0185*screenHeight) .. [["
            stroke="]]..lineColor..[[" stroke-width="2" fill="]]..bgColor..[[" />
        
            <path d="
                M ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[
                L ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[
                L ]] .. tostring(.61*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [[
                L ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.0645*screenHeight) .. [[
                L ]] .. tostring(.39*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [["
            stroke="]]..lineColor..[[" stroke-width="1" fill="url(#sFuel)" />
        
            <path d="
                M ]] .. tostring(.5*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[ 
                L ]] .. tostring(.5*screenWidth) .. ' ' .. tostring(.070*screenHeight) .. [["
            stroke="black" stroke-width="1.5" fill="none" />
        
            <path d="
                M ]] .. tostring(.555*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[ 
                L ]] .. tostring(.555*screenWidth) .. ' ' .. tostring(.070*screenHeight) .. [["
            stroke="black" stroke-width="1.5" fill="none" />
        
            <path d="
                M ]] .. tostring(.445*screenWidth) .. ' ' .. tostring(.055*screenHeight) .. [[ 
                L ]] .. tostring(.445*screenWidth) .. ' ' .. tostring(.070*screenHeight) .. [["
            stroke="black" stroke-width="1.5" fill="none" />
        
            <text x="]].. tostring(.39 * screenWidth) ..[[" y="]].. tostring(.08 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">Fuel: ]] .. curFuelStr .. [[</text>
            <!--text x="]].. tostring(.445 * screenWidth) ..[[" y="]].. tostring(.08 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">25%</text>
            <text x="]].. tostring(.5 * screenWidth) ..[[" y="]].. tostring(.08 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">50%</text>
            <text x="]].. tostring(.555 * screenWidth) ..[[" y="]].. tostring(.08 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">75%</text-->
        
        
            ]]
        
            if fuelTankWarning or fuelWarning then
                local warningText = 'Fuel level below 20%'
                if not fuelWarning then warningText = 'Fuel tank is below 20%' end
                fw = fw .. [[
                        <rect x="45vw" y="9vh" rx="10" ry="10" width="9vw" height="2.25vh" style="fill:rgba(50, 50, 50, 0.5);stroke:rgba(255, 60, 60, 0.9);stroke-width:5;opacity:0.95;" />
                        <text x="]].. tostring(.455 * screenWidth) ..[[" y="]].. tostring(.105 * screenHeight) ..[[" style="fill: rgb(255, 60, 60);" font-size=".8vw" font-weight="bold">]]..warningText..[[</text>
                ]]
            end
        
            fw = fw .. '</svg>'
        
            return fw
        end
        
        function apStatusWidget()
            local bg = bgColor
            local apStatus = 'inactive'
            if auto_follow then bg = 'rgba(99, 250, 79, 0.5)' apStatus = 'following' end
            if autopilot then bg = 'rgba(99, 250, 79, 0.5)' apStatus = 'Engaged' end
            if not autopilot and autopilot_dest ~= nil then apStatus = 'Set' end
            local apw = [[
                    <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                    -- Left Top Side]]
            apw = apw .. [[<path d="
                M ]] .. tostring(.3365*screenWidth) .. ' ' .. tostring(.028*screenHeight) .. [[ 
                L ]] .. tostring(.309*screenWidth) .. ' ' .. tostring(.0387*screenHeight) .. [[
                L ]] .. tostring(.2*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                L ]] .. tostring(.31*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                L ]] .. tostring(.3365*screenWidth) .. ' ' .. tostring(.0185*screenHeight) .. [[
                L ]] .. tostring(.3365*screenWidth) .. ' ' .. tostring(.028*screenHeight) .. [["
                stroke="]]..lineColor..[[" stroke-width="1" fill="]]..bg..[[" />
                
                <text x="]].. tostring(.25 * screenWidth) ..[[" y="]].. tostring(.012 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold" transform="rotate(10,]].. tostring(.25 * screenWidth) ..",".. tostring(.012 * screenHeight) ..[[)">AutoPilot: ]]..apStatus..[[</text>
        
                
                </svg>]]
            return apw
        end
        
        function positionInfoWidget()
            local piw = [[
                    <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                    -- Far Left Top Side]]
            piw = piw .. [[<path d="
                M ]] .. tostring(.0*screenWidth) .. ' ' .. tostring(.0155*screenHeight) .. [[ 
                L ]] .. tostring(.115*screenWidth) .. ' ' .. tostring(.0155*screenHeight) .. [[
                L ]] .. tostring(.124*screenWidth) .. ' ' .. tostring(.025*screenHeight) .. [[
                L ]] .. tostring(.25*screenWidth) .. ' ' .. tostring(.035*screenHeight) .. [[
                L ]] .. tostring(.275*screenWidth) .. ' ' .. tostring(.027*screenHeight) .. [[
                L ]] .. tostring(.2*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                L ]] .. tostring(.0*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                L ]] .. tostring(.0*screenWidth) .. ' ' .. tostring(.0155*screenHeight) .. [[ 
                "
                stroke="]]..lineColor..[[" stroke-width="1" fill="]]..bgColor..[[" />
        
                <path d="
                M ]] .. tostring(1.0*screenWidth) .. ' ' .. tostring(.0155*screenHeight) .. [[ 
                L ]] .. tostring(.885*screenWidth) .. ' ' .. tostring(.0155*screenHeight) .. [[
                L ]] .. tostring(.876*screenWidth) .. ' ' .. tostring(.025*screenHeight) .. [[
                L ]] .. tostring(.75*screenWidth) .. ' ' .. tostring(.035*screenHeight) .. [[
                L ]] .. tostring(.725*screenWidth) .. ' ' .. tostring(.027*screenHeight) .. [[
                L ]] .. tostring(.8*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                L ]] .. tostring(1.0*screenWidth) .. ' ' .. tostring(.001*screenHeight) .. [[
                L ]] .. tostring(1.0*screenWidth) .. ' ' .. tostring(.0155*screenHeight) .. [[ 
                "
                stroke="]]..lineColor..[[" stroke-width="1" fill="]]..bgColor..[[" />
                
                <text x="]].. tostring(.001 * screenWidth) ..[[" y="]].. tostring(.01 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".6vw">Remote Version: ]]..hudVersion..[[</text>
                <text x="]].. tostring(.125 * screenWidth) ..[[" y="]].. tostring(.011 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Nearest Planet</text>
                <text x="]].. tostring(.15 * screenWidth) ..[[" y="]].. tostring(.022 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".7vw" >]]..closestPlanetStr..[[</text>
                
                <text x="]].. tostring(.82 * screenWidth) ..[[" y="]].. tostring(.011 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".8vw" font-weight="bold">Nearest Pipe</text>
                <text x="]].. tostring(.78 * screenWidth) ..[[" y="]].. tostring(.022 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".7vw" >]]..closestPipeStr..[[</text>
        
                <text x="]].. tostring(.90 * screenWidth) ..[[" y="]].. tostring(.011 * screenHeight) ..[[" style="fill: ]]..textColor..[[" font-size=".7vw" font-weight="bold">Safe Zone Distance: ]]..SZDStr..[[</text>
        
                </svg>]]
            return piw
        end
        
        function engineWidget()
            local ew = [[
                <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                    <text x="]].. tostring(.001 * screenWidth) ..[[" y="]].. tostring(.045 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">Controlling Engine tags</text>
                    ]]..enabledEngineTagsStr..[[
                </svg>
            ]]
            return ew
        end
        
        function planetARWidget()
            local arw = planetAR
            arw = arw .. [[
                <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                    <text x="]].. tostring(.001 * screenWidth) ..[[" y="]].. tostring(.03 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">Augmented Reality Mode: ]]..AR_Mode..[[</text>
                </svg>
            ]]
        
            return arw
        end
        
        function helpWidget()
            local hw = ''
            if showHelp then
                hw = [[
                    <svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">
                    <rect x="]].. tostring(.125 * screenWidth) ..[[" y="]].. tostring(.125 * screenHeight) ..[[" rx="15" ry="15" width="60vw" height="22vh" style="fill:rgba(50, 50, 50, 0.9);stroke:white;stroke-width:5;opacity:0.9;" />
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.15 * screenHeight) ..[[" style="fill: ]]..'orange'..[[" font-size=".8vw" font-weight="bold">
                        OPTION KEY BINDINGS</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.17 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+1: Toggle help screen</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.19 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+2: Toggle Augmented reality view mode (NONE, ALL, PLANETS, CUSTOM) HUD Loads custom waypoints for AR from "autoconf/custom/AR_Waypoints.lua"</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.21 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+3: Clear all engine tag filters (i.e. all engines controlled by throttle) (Alt+shift+3 toggles through predefined tags)</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.23 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+4: Engage AutoPilot to current AP destination (shown in VR)</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.25 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+5: Engage Follow Mode. Ship will attempt to mirror the speed of the target construct (or close the gap if to far away). REQUIRES an identified and targeted construct in radar</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.27 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+6: Set AutoPilot destination to the nearest safe zone</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.29 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+7: Toggles radar widget filtering mode (Show all, Show Enemy, Show Identified, Show Friendly)</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.31 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+8: Toggle Shield vent. Start venting if available. Stop venting if currently venting</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.33 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        Alt+9: Toggle between Cruise and Throttle control modes</text>
                    </rect>
                    
                    <rect x="]].. tostring(.125 * screenWidth) ..[[" y="]].. tostring(.365 * screenHeight) ..[[" rx="15" ry="15" width="60vw" height="22vh" style="fill:rgba(50, 50, 50, 0.9);stroke:white;stroke-width:5;opacity:0.9;" />
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.39 * screenHeight) ..[[" style="fill: ]]..'orange'..[[" font-size=".8vw" font-weight="bold">
                        Lua Commands</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.41 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        disable &lt;tag&gt;: Disables control of engines tagged with the <tag> parameter</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.43 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        enable &lt;tag&gt;: Enables control of engines tagged with <tag></text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.45 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        warpFrom &lt;start position&gt; &lt;destination position&gt;: Calculates best warp bath from the <start position> (positions are in ::pos{} format)</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.47 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        warp &lt;destination position&gt;: Calculates best warp path from current postion to destination (position is in ::pos{} format)</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.49 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        addWaypoint &lt;waypoint1&gt; &lt;Name&gt;: Adds temporary AR points when enabled. Requires a position tag. Optionally, you can also optionally add a custom name as well</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.51 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        delWaypoint &lt;name&gt;: Removes the specified temporary AR point</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.53 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        addShips db: Adds all ships currently on radar to the friendly construct list</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.55 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        code &lt;transponder code&gt;: Adds the transponder tag to the transponder. "delcode &lt;code&gt;" removes the tag</text>
                    <text x="]].. tostring(.13 * screenWidth) ..[[" y="]].. tostring(.57 * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw" font-weight="bold">
                        &lt;Primary Target ID&gt;: Filters radar widget to only show the construct with the specified ID</text>
                    </rect>
        
                    </svg>
                ]]
            else
                hw = ''
            end
        
            return hw
        end
        
        function travelIndicatorWidget()
            local p = constructPosition + 2/.000005 * vec3(construct.getWorldOrientationForward())
            local pInfo = library.getPointOnScreen({p['x'],p['y'],p['z']})
        
            local tiw = '<svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">'
            if pInfo[3] ~= 0 then
                if pInfo[1] < .01 then pInfo[1] = .01 end
                if pInfo[2] < .01 then pInfo[2] = .01 end
                local fill = AR_Fill
                local translate = '(0,0)'
                local depth = '8'           
                if pInfo[1] < 1 and pInfo[2] < 1 then
                    translate = string.format('(%.2f,%.2f)',screenWidth*pInfo[1],screenHeight*pInfo[2])
                elseif pInfo[1] > 1 and pInfo[1] < AR_Range and pInfo[2] < 1 then
                    translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight*pInfo[2])
                elseif pInfo[2] > 1 and pInfo[2] < AR_Range and pInfo[1] < 1 then
                    translate = string.format('(%.2f,%.2f)',screenWidth*pInfo[1],screenHeight)
                else
                    translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight)
                end
                tiw = tiw .. [[<g transform="translate]]..translate..[[">
                        <circle cx="0" cy="0" r="]].. Direction_Indicator_Size ..[[px" style="fill:lightgrey;stroke:]]..Direction_Indicator_Color..[[;stroke-width:]]..tostring(Indicator_Width)..[[;opacity:]].. 0.5 ..[[;" />
                        <line x1="]].. Direction_Indicator_Size*1.5 ..[[" y1="0" x2="]].. -Direction_Indicator_Size*1.5 ..[[" y2="0" style="stroke:]]..Direction_Indicator_Color..[[;stroke-width:]]..tostring(Indicator_Width/5)..[[;opacity:]].. 0.85 ..[[;" />
                        <line y1="]].. Direction_Indicator_Size*1.5 ..[[" x1="0" y2="]].. -Direction_Indicator_Size*1.5 ..[[" x2="0" style="stroke:]]..Direction_Indicator_Color..[[;stroke-width:]]..tostring(Indicator_Width/5)..[[;opacity:]].. 0.85 ..[[;" />
                        </g>]]
            end
            if speed > 20 then
                local a = constructPosition + 2/.000005 * vec3(construct.getWorldVelocity())
                local aInfo = library.getPointOnScreen({a['x'],a['y'],a['z']})
                if aInfo[3] ~= 0 then
                    if aInfo[1] < .01 then aInfo[1] = .01 end
                    if aInfo[2] < .01 then aInfo[2] = .01 end
                    local fill = AR_Fill
                    local translate = '(0,0)'
                    local depth = '8'           
                    if aInfo[1] < 1 and aInfo[2] < 1 then
                        translate = string.format('(%.2f,%.2f)',screenWidth*aInfo[1],screenHeight*aInfo[2])
                    elseif aInfo[1] > 1 and aInfo[1] < AR_Range and aInfo[2] < 1 then
                        translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight*aInfo[2])
                    elseif aInfo[2] > 1 and aInfo[2] < AR_Range and aInfo[1] < 1 then
                        translate = string.format('(%.2f,%.2f)',screenWidth*aInfo[1],screenHeight)
                    else
                        translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight)
                    end
                    tiw = tiw .. [[<g transform="translate]]..translate..[[">
                            <circle cx="0" cy="0" r="]].. Prograde_Indicator_Size ..[[px" style="fill:none;stroke:]]..Prograde_Indicator_Color..[[;stroke-width:]]..tostring(Indicator_Width)..[[;opacity:]].. 0.5 ..[[;" />
                            <line x1="]].. Prograde_Indicator_Size*1.4 ..[[" y1="]].. Prograde_Indicator_Size*1.4 ..[[" x2="]].. -Prograde_Indicator_Size*1.4 ..[[" y2="]].. -Prograde_Indicator_Size*1.4 ..[[" style="stroke:]]..Prograde_Indicator_Color..[[;stroke-width:]]..tostring(Indicator_Width/5)..[[;opacity:]].. 0.85 ..[[;" />
                            <line x1="]].. -Prograde_Indicator_Size*1.4 ..[[" y1="]].. Prograde_Indicator_Size*1.4 ..[[" x2="]].. Prograde_Indicator_Size*1.4 ..[[" y2="]].. -Prograde_Indicator_Size*1.4 ..[[" style="stroke:]]..Prograde_Indicator_Color..[[;stroke-width:]]..tostring(Indicator_Width/5)..[[;opacity:]].. 0.85 ..[[;" />
                            </g>]]
                end
                local r = constructPosition - 2/.000005 * vec3(construct.getWorldVelocity())
                local aInfo = library.getPointOnScreen({r['x'],r['y'],r['z']})
                if aInfo[3] ~= 0 then
                    if aInfo[1] < .01 then aInfo[1] = .01 end
                    if aInfo[2] < .01 then aInfo[2] = .01 end
                    local fill = AR_Fill
                    local translate = '(0,0)'
                    local depth = '8'           
                    if aInfo[1] < 1 and aInfo[2] < 1 then
                        translate = string.format('(%.2f,%.2f)',screenWidth*aInfo[1],screenHeight*aInfo[2])
                    elseif aInfo[1] > 1 and aInfo[1] < AR_Range and aInfo[2] < 1 then
                        translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight*aInfo[2])
                    elseif aInfo[2] > 1 and aInfo[2] < AR_Range and aInfo[1] < 1 then
                        translate = string.format('(%.2f,%.2f)',screenWidth*aInfo[1],screenHeight)
                    else
                        translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight)
                    end
                    tiw = tiw .. [[<g transform="translate]]..translate..[[">
                            <circle cx="0" cy="0" r="]].. Prograde_Indicator_Size ..[[px" style="fill:none;stroke:rgb(255, 60, 60);stroke-width:]]..tostring(Indicator_Width)..[[;opacity:]].. 0.5 ..[[;" />
                            <line x1="]].. Prograde_Indicator_Size*1.4 ..[[" y1="]].. Prograde_Indicator_Size*1.4 ..[[" x2="]].. -Prograde_Indicator_Size*1.4 ..[[" y2="]].. -Prograde_Indicator_Size*1.4 ..[[" style="stroke:rgb(255, 60, 60);stroke-width:]]..tostring(Indicator_Width/5)..[[;opacity:]].. 0.85 ..[[;" />
                            <line x1="]].. -Prograde_Indicator_Size*1.4 ..[[" y1="]].. Prograde_Indicator_Size*1.4 ..[[" x2="]].. Prograde_Indicator_Size*1.4 ..[[" y2="]].. -Prograde_Indicator_Size*1.4 ..[[" style="stroke:rgb(255, 60, 60);stroke-width:]]..tostring(Indicator_Width/5)..[[;opacity:]].. 0.85 ..[[;" />
                            </g>]]
                end
            end
            tiw = tiw .. '</svg>'
            return tiw
        end
        
        
        
        function generateScreen()
            html = [[ <html> <body style="font-family: Calibri;"> ]]
            html = html .. brakeWidget()
            html = html .. flightWidget()
            html = html .. fuelWidget()
            html = html .. apStatusWidget()
            html = html .. positionInfoWidget()
            html = html .. engineWidget()
            html = html .. planetARWidget()
            html = html .. helpWidget()
            html = html .. travelIndicatorWidget()
        
            html = html .. [[ </body> </html> ]]
            system.setScreen(html)
        end
        
        function globalDB(action)
            if db_1 ~= nil then
                if action == 'get' then
                    if db_1.hasKey('showRemotePanel') == 1 then showRemotePanel = db_1.getIntValue('showRemotePanel') == 1 end
                    if db_1.hasKey('showDockingPanel') == 1 then showDockingPanel = db_1.getIntValue('showDockingPanel') == 1 end
                    if db_1.hasKey('showFuelPanel') == 1 then showFuelPanel = db_1.getIntValue('showFuelPanel') == 1 end
                    if db_1.hasKey('showHelper') == 1 then showHelper = db_1.getIntValue('showHelper') == 1 end
                    if db_1.hasKey('defaultHoverHeight') == 1 then defaultHoverHeight = db_1.getIntValue('defaultHoverHeight') end
                    if db_1.hasKey('defautlFollowDistance') == 1 then defautlFollowDistance = db_1.getIntValue('defautlFollowDistance') end
                    if db_1.hasKey('topHUDLineColorSZ') == 1 then topHUDLineColorSZ = db_1.getStringValue('topHUDLineColorSZ') end
                    if db_1.hasKey('topHUDFillColorSZ') == 1 then topHUDFillColorSZ = db_1.getStringValue('topHUDFillColorSZ') end
                    if db_1.hasKey('textColorSZ') == 1 then textColorSZ = db_1.getStringValue('textColorSZ') end
                    if db_1.hasKey('topHUDLineColorPVP') == 1 then topHUDLineColorPVP = db_1.getStringValue('topHUDLineColorPVP') end
                    if db_1.hasKey('topHUDFillColorPVP') == 1 then topHUDFillColorPVP = db_1.getStringValue('topHUDFillColorPVP') end
                    if db_1.hasKey('textColorPVP') == 1 then textColorPVP = db_1.getStringValue('textColorPVP') end
                    if db_1.hasKey('fuelTextColor') == 1 then fuelTextColor = db_1.getStringValue('fuelTextColor') end
                    if db_1.hasKey('Direction_Indicator_Size') == 1 then Direction_Indicator_Size = db_1.getFloatValue('Direction_Indicator_Size') end
                    if db_1.hasKey('Direction_Indicator_Color') == 1 then Direction_Indicator_Color = db_1.getStringValue('Direction_Indicator_Color') end
                    if db_1.hasKey('Prograde_Indicator_Size') == 1 then Prograde_Indicator_Size = db_1.getFloatValue('Prograde_Indicator_Size') end
                    if db_1.hasKey('Prograde_Indicator_Color') == 1 then Prograde_Indicator_Color = db_1.getStringValue('Prograde_Indicator_Color') end
                    if db_1.hasKey('AP_Brake_Buffer') == 1 then AP_Brake_Buffer = db_1.getFloatValue('AP_Brake_Buffer') end
                    if db_1.hasKey('AP_Max_Rotation_Factor') == 1 then AP_Max_Rotation_Factor = db_1.getFloatValue('AP_Max_Rotation_Factor') end
                    if db_1.hasKey('AR_Mode') == 1 then AR_Mode = db_1.getStringValue('AR_Mode') end
                    if db_1.hasKey('AR_Range') == 1 then AR_Range = db_1.getFloatValue('AR_Range') end
                    if db_1.hasKey('AR_Size') == 1 then AR_Size = db_1.getFloatValue('AR_Size') end
                    if db_1.hasKey('AR_Fill') == 1 then AR_Fill = db_1.getStringValue('AR_Fill') end
                    if db_1.hasKey('AR_Outline') == 1 then AR_Outline = db_1.getStringValue('AR_Outline') end
                    if db_1.hasKey('AR_Opacity') == 1 then AR_Opacity = db_1.getStringValue('AR_Opacity') end
                    if db_1.hasKey('AR_Exclude_Moons') == 1 then AR_Exclude_Moons = db_1.getIntValue('AR_Exclude_Moons') == 1 end
                    if db_1.hasKey('EngineTagColor') == 1 then EngineTagColor = db_1.getStringValue('EngineTagColor') end
                    if db_1.hasKey('Indicator_Width') == 1 then Indicator_Width = db_1.getFloatValue('Indicator_Width') end
                elseif action == 'save' then
                    if showRemotePanel then db_1.setIntValue('showRemotePanel',1) else db_1.setIntValue('showRemotePanel',0) end
                    if showDockingPanel then db_1.setIntValue('showDockingPanel',1) elsedb_1.setIntValue('showDockingPanel',0) end
                    if showFuelPanel then db_1.setIntValue('showFuelPanel',1) else db_1.setIntValue('showFuelPanel',0) end
                    if showHelper then db_1.setIntValue('showHelper',1) else db_1.setIntValue('showHelper',0) end
                    db_1.setIntValue('defaultHoverHeight',defaultHoverHeight)
                    db_1.setIntValue('defautlFollowDistance',defautlFollowDistance)
                    db_1.setStringValue('topHUDLineColorSZ',topHUDLineColorSZ)
                    db_1.setStringValue('topHUDFillColorSZ',topHUDFillColorSZ)
                    db_1.setStringValue('textColorSZ',textColorSZ)
                    db_1.setStringValue('topHUDLineColorPVP',topHUDLineColorPVP)
                    db_1.setStringValue('topHUDFillColorPVP',topHUDFillColorPVP)
                    db_1.setStringValue('textColorPVP',textColorPVP)
                    db_1.setStringValue('fuelTextColor',fuelTextColor)
                    db_1.setFloatValue('Direction_Indicator_Size',Direction_Indicator_Size)
                    db_1.setStringValue('Direction_Indicator_Color',Direction_Indicator_Color)
                    db_1.setFloatValue('Prograde_Indicator_Size',Prograde_Indicator_Size) 
                    db_1.setStringValue('Prograde_Indicator_Color',Prograde_Indicator_Color) 
                    db_1.setFloatValue('AP_Brake_Buffer',AP_Brake_Buffer)
                    db_1.setFloatValue('AP_Max_Rotation_Factor',AP_Max_Rotation_Factor)
                    db_1.setStringValue('AR_Mode',AR_Mode)
                    db_1.setFloatValue('AR_Range',AR_Range)
                    db_1.setFloatValue('AR_Size',AR_Size)
                    db_1.setStringValue('AR_Fill',AR_Fill)
                    db_1.setStringValue('AR_Outline',AR_Outline)
                    db_1.setStringValue('AR_Opacity',AR_Opacity)
                    db_1.setStringValue('EngineTagColor',EngineTagColor)
                    db_1.setFloatValue('Indicator_Width',Indicator_Width)
                    if AR_Exclude_Moons then db_1.setIntValue('AR_Exclude_Moons',1) else db_1.setIntValue('AR_Exclude_Moons',0) end
                end
            end
        end
        
        Kinematic = {} -- just a namespace
        local C = 100000000 / 3600
        local C2 = C * C
        local ITERATIONS = 100 -- iterations over engine "warm-up" period
        
        function Kinematic.computeDistanceAndTime(initial, final, restMass, thrust, t50, brakeThrust)
        
            t50 = t50 or 0
            brakeThrust = brakeThrust or 0 -- usually zero when accelerating
            local speedUp = initial <= final
            local a0 = thrust * (speedUp and 1 or -1) / restMass
            local b0 = -brakeThrust / restMass
            local totA = a0 + b0
            if speedUp and totA <= 0 or not speedUp and totA >= 0 then
                return -1, -1 -- no solution
            end
            local distanceToMax, timeToMax = 0, 0
        
            if a0 ~= 0 and t50 > 0 then
        
                local k1 = math.asin(initial / C)
                local c1 = math.pi * (a0 / 2 + b0)
                local c2 = a0 * t50
                local c3 = C * math.pi
                local v = function(t)
                    local w = (c1 * t - c2 * math.sin(math.pi * t / 2 / t50) + c3 * k1) / c3
                    local tan = math.tan(w)
                    return C * tan / msqrt(tan * tan + 1)
                end
                local speedchk = speedUp and function(s)
                    return s >= final
                end or function(s)
                    return s <= final
                end
                timeToMax = 2 * t50
                if speedchk(v(timeToMax)) then
                    local lasttime = 0
                    while mabs(timeToMax - lasttime) > 0.5 do
                        local t = (timeToMax + lasttime) / 2
                        if speedchk(v(t)) then
                            timeToMax = t
                        else
                            lasttime = t
                        end
                    end
                end
                -- There is no closed form solution for distance in this case.
                -- Numerically integrate for time t=0 to t=2*T50 (or less)
                local lastv = initial
                local tinc = timeToMax / ITERATIONS
                for step = 1, ITERATIONS do
                    local speed = v(step * tinc)
                    distanceToMax = distanceToMax + (speed + lastv) * tinc / 2
                    lastv = speed
                end
                if timeToMax < 2 * t50 then
                    return distanceToMax, timeToMax
                end
                initial = lastv
            end
        
            local k1 = C * math.asin(initial / C)
            local time = (C * math.asin(final / C) - k1) / totA
            local k2 = C2 * math.cos(k1 / C) / totA
            local distance = k2 - C2 * math.cos((totA * time + k1) / C) / totA
            return distance + distanceToMax, time + timeToMax
        end
        
        function Kinematic.lorentz(v) return lorentz(v) end
        
        function isNumber(n)  return type(n)           == 'number' end
        function isSNumber(n) return type(tonumber(n)) == 'number' end
        function isTable(t)   return type(t)           == 'table'  end
        function isString(s)  return type(s)           == 'string' end
        function isVector(v)  return isTable(v) and isNumber(v.x and v.y and v.z) end
        
        
        
        ---------------------- TRANSFORM -------------------------
        clamp = utils.clamp
        
        Transform = {}
        
        --
        -- computeHeading - compute compass heading corresponding to a direction.
        -- planetCenter[in]: planet's center in world coordinates.
        -- position    [in]: construct's position in world coordinates.
        -- direction   [in]: the direction in world coordinates of the heading.
        -- return: the heading in radians where 0 is North, PI is South.
        -- 
        function Transform.computeHeading(planetCenter, position, direction)
            planetCenter   = vec3(planetCenter)
            position       = vec3(position)
            direction      = vec3(direction)
            local radius   = position - planetCenter
            if radius.x == 0 and radius.y == 0 then -- at north or south pole
                return radius.z >=0 and math.pi or 0
            end
            local chord    = planetCenter + vec3(0,0,radius:len()) - position
            local north    = chord:project_on_plane(radius):normalize_inplace()
            -- facing north, east is to the right
            local east     = north:cross(radius):normalize_inplace()
            local dir_prj  = direction:project_on_plane(radius):normalize_inplace()
            local adjacent = north:dot(dir_prj)
            local opposite = east:dot(dir_prj)
            local heading  = math.atan(opposite, adjacent) -- North==0
        
            if heading < 0 then heading = heading + 2*math.pi end
            if math.abs(heading - 2*math.pi) < .001 then heading = 0 end
            return heading
        end
        
        function Transform.computePRYangles(yaxis, zaxis, faxis, uaxis)
            yaxis = yaxis.x and yaxis or vec3(yaxis)
            zaxis = zaxis.x and zaxis or vec3(zaxis)
            faxis = faxis.x and faxis or vec3(faxis)
            uaxis = uaxis.x and uaxis or vec3(uaxis)
            local zproject = zaxis:project_on_plane(faxis):normalize_inplace()
            local adjacent = uaxis:dot(zproject)
            local opposite = faxis:cross(zproject):dot(uaxis)
            local roll     = math.atan(opposite, adjacent) -- rotate 'up' around 'fwd'
            local pitch    = math.asin(clamp(faxis:dot(zaxis), -1, 1))
            local fproject = faxis:project_on_plane(zaxis):normalize_inplace()
            local yaw      = math.asin(clamp(yaxis:cross(fproject):dot(zaxis), -1, 1))
            return pitch, roll, yaw
        end
    onUpdate:
      lua: |
        Nav:update()
        
        -- Check player seated status --
        seated = player.isSeated()
        if seated == 1 and player.isFrozen() == 0 then
            player.freeze(1)
        elseif seated == 0 and player.isFrozen() == 1 then
            player.freeze(0)
        end
        ----------------------------------
        
        -- Closest Planet/Pipe info --
        closestPlanetName,closestPlanetDist = closestPlanet()
        closestPipeName,closestPipeDistance = closestPipe()
        closestPipeStr = ''
        if closestPipeDistance < 1000 then closestPipeStr = string.format('%s (%.2f m)',closestPipeName,closestPipeDistance)
        elseif closestPipeDistance < 100000 then closestPipeStr = string.format('%s (%.2f km)',closestPipeName,closestPipeDistance/1000)
        else closestPipeStr = string.format('%s (%.2f SU)',closestPipeName,closestPipeDistance*.000005)
        end
        closestPlanetStr = ''
        if closestPlanetDist < 1000 then closestPlanetStr = string.format('%s (%.2f m)',closestPlanetName,closestPlanetDist)
        elseif closestPlanetDist < 100000 then closestPlanetStr = string.format('%s (%.2f km)',closestPlanetName,closestPlanetDist/1000)
        else closestPlanetStr = string.format('%s (%.2f SU)',closestPlanetName,closestPlanetDist*.000005)
        end
        
        -- Disable AutoPilot if to close to planet --
        if closestPlanetDist < 40000 and autopilot then 
            autopilot = false 
            brakeInput = 1
            brakesOn = true
            system.print('-- autopilot canceled due to planet proximity --')
        end
        
        -- Safe Zone Distance --
        inSZ = construct.isInPvPZone() == 0
        SZD = math.abs(construct.getDistanceToSafeZone())
        local tempSZD = vec3(constructPosition - SZ):len()
        nearestSZPOS = system.getWaypointFromPlayerPos()
        if closestPlanetDist < math.abs(tempSZD - 18000000) then
            local cPlanet = planets[closestPlanetName]
            nearestSZPOS = string.format('::pos{0,0,%.4f,%.4f,%.4f}',cPlanet['x'],cPlanet['y'],cPlanet['z'])
        else
            nearestSZPOS = '::pos{0,0,13771471,7435803,-128971}'
        end
        
        SZDStr = ''
        if SZD < 1000 then SZDStr = string.format('%.2f m',SZD)
        elseif SZD < 100000 then SZDStr = string.format('%.2f km',SZD/1000)
        else SZDStr = string.format('%.2f su',SZD*.000005)
        end
        ---------------------------
        
        -- Engine Tag Filtering --
        enabledEngineTagsStr = ''
        local tempTag = nil
        local offset = 0
        for i,tag in pairs(enabledEngineTags) do
            if i % 2 == 0 then 
                enabledEngineTagsStr = enabledEngineTagsStr .. [[
                    <text x="]].. tostring(.001 * screenWidth) ..[[" y="]].. tostring((.060 + (i-2)*.008) * screenHeight) ..[[" style="fill: ]]..EngineTagColor..[[;" font-weight="bold" font-size=".8vw">]]..tag.. ',' ..tempTag..[[</text>    
                ]]
                tempTag = nil
                offset = offset + 1
            else
                tempTag = tag
            end
        end
        if tempTag ~= nil then 
            enabledEngineTagsStr = enabledEngineTagsStr .. [[<text x="]].. tostring(.001 * screenWidth) ..[[" y="]].. tostring((.060 + (offset)*.016) * screenHeight) ..[[" style="fill: ]]..EngineTagColor..[[;" font-weight="bold" font-size=".8vw">]]..tempTag..[[</text>]]
        end
        if enabledEngineTagsStr == '' then
            enabledEngineTagsStr = [[<text x="]].. tostring(.001 * screenWidth) ..[[" y="]].. tostring((.060 + (offset)*.008) * screenHeight) ..[[" style="fill: ]]..fuelTextColor..[[" font-size=".8vw">ALL</text>]]
        end
        ----------------------------
        
        -- Auto Follow feature --
        if auto_follow then 
            if not db_1 then
                auto_follow = false
                system.print('-- No databank attached --')
            elseif db_1.hasKey('targetID') == 1 then
                targetID = db_1.getIntValue('targetID')
                if followID == nil or targetID == followID then
                    followID = targetID
                    targetSpeed = db_1.getFloatValue('targetSpeed')
                    targetDist = db_1.getFloatValue('targetDistance')
                    local followBrakeDist = 0
                    if math.abs(speed/3.6 - targetSpeed) > 5 then
                        followBrakeDist,followBrakeTime = Kinematic.computeDistanceAndTime(speed/3.6,targetSpeed,mass,0,0,maxBrake)
                    end
                    if db_1.hasKey('followDistance') == 1 then followDistance = db_1.getFloatValue('followDistance') else followDistance = defautlFollowDistance end
                    followDistance = followDistance + followBrakeDist
                    if followDistance > targetDist and followDistance - followDistance*.1 < targetDist then 
                        -- Set cruise speed to targets speed
                        brakeInput = 0
                        Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
                        if (Nav.axisCommandManager:getAxisCommandType(0) ~= axisCommandType.byTargetSpeed) then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        Nav.axisCommandManager:setTargetSpeedCommand(axisCommandId.longitudinal,targetSpeed)
                    elseif followDistance < targetDist then
                        -- Full throttle
                        brakeInput = 0
                        if (Nav.axisCommandManager:getAxisCommandType(0) ~= axisCommandType.byThrottle) then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,1)
                    elseif followDistance - followDistance*.1 > targetDist then
                        -- Full brake
                        brakeInput = 1
                        if (Nav.axisCommandManager:getAxisCommandType(0) ~= axisCommandType.byThrottle) then
                            Nav.control.cancelCurrentControlMasterMode()
                        end
                        Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,0)
                    end
                elseif followID ~= targetID then
                    if (Nav.axisCommandManager:getAxisCommandType(0) ~= axisCommandType.byThrottle) then
                        Nav.control.cancelCurrentControlMasterMode()
                    end
                    Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,0)
                    system.print('-- Auto follow cancelled due to target change --')
                    followID = nil
                    auto_follow = false
                    db_1.clearValue('followDistance')
                    db_1.clearValue('targetDistance')
                    db_1.clearValue('targetSpeed')
                    db_1.clearValue('targetID')
                end
            else
                auto_follow = false
                system.print('-- No target found for following --')
            end
        end
        if db_1 then 
            if auto_follow then
                db_1.setIntValue('following',1)
                db_1.setIntValue('followingID',followID)
            else
                followID = nil
                db_1.setIntValue('following',0)
                db_1.setIntValue('followingID',0)
            end
        end
        ---------------------------
        
        -- Generate on screen planets for Augmented Reality view --
        AR_Generate = {}
        if autopilot_dest_pos ~= nil then AR_Generate['AutoPilot'] = convertWaypoint(autopilot_dest_pos) end
        if AR_Mode == 'ALL' then
            for k,v in pairs(AR_Custom_Points) do 
                AR_Generate[k] = convertWaypoint(v)
            end
            for k,v in pairs(planets) do
                AR_Generate[k] = v
            end
            for k,v in pairs(AR_Temp_Points) do 
                AR_Generate[k] = convertWaypoint(v)
            end
        elseif AR_Mode == 'FROM_FILE' then
            for k,v in pairs(AR_Custom_Points) do 
                AR_Generate[k] = convertWaypoint(v)
            end
        elseif AR_Mode == 'TEMPORARY' then
            for k,v in pairs(AR_Temp_Points) do 
                AR_Generate[k] = convertWaypoint(v)
            end
        elseif AR_Mode == 'PLANETS' then
            for k,v in pairs(planets) do
                AR_Generate[k] = v
            end
        end
        planetAR = '<svg width="100%" height="100%" style="position: absolute;left:0%;top:0%;font-family: Calibri;">'
        for name,pos in pairs(AR_Generate) do
            if not (name:find('Moon') or name:find('Haven') or name:find('Sanctuary')) or not AR_Exclude_Moons then
                local pDist = vec3(pos - constructPosition):len()
                if pDist*0.000005 < 500  or planets[name] == nil then 
                    local pInfo = library.getPointOnScreen({pos['x'],pos['y'],pos['z']})
                    if pInfo[3] ~= 0 then
                        if pInfo[1] < .01 then pInfo[1] = .01 end
                        if pInfo[2] < .01 then pInfo[2] = .01 end
                        local fill = AR_Fill
                        if planets[name] == nil  and name ~= 'AutoPilot' then fill = 'rgb(49, 182, 60)'
                        elseif name == 'AutoPilot' then fill = 'red'
                        end
                        local translate = '(0,0)'
                        local depth = AR_Size * 1/( 0.02*pDist*0.000005)
                        local pDistStr = ''
                        if pDist < 1000 then pDistStr = string.format('%.2fm',pDist)
                        elseif pDist < 100000 then pDistStr = string.format('%.2fkm',pDist/1000)
                        else pDistStr = string.format('%.2fsu',pDist*0.000005)
                        end
                        if depth > AR_Size then depth = tostring(AR_Size) elseif depth < 1 then depth = '1' else depth = tostring(depth) end
                        if pInfo[1] < 1 and pInfo[2] < 1 then
                            translate = string.format('(%.2f,%.2f)',screenWidth*pInfo[1],screenHeight*pInfo[2])
                        elseif pInfo[1] > 1 and pInfo[1] < AR_Range and pInfo[2] < 1 then
                            translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight*pInfo[2])
                        elseif pInfo[2] > 1 and pInfo[2] < AR_Range and pInfo[1] < 1 then
                            translate = string.format('(%.2f,%.2f)',screenWidth*pInfo[1],screenHeight)
                        else
                            translate = string.format('(%.2f,%.2f)',screenWidth,screenHeight)
                        end
                        planetAR = planetAR .. [[<g transform="translate]]..translate..[[">
                                <circle cx="0" cy="0" r="]].. depth ..[[px" style="fill:]]..fill..[[;stroke:]]..AR_Outline..[[;stroke-width:1;opacity:]]..AR_Opacity..[[;" />
                                <line x1="0" y1="0" x2="-]].. depth*1.2 ..[[" y2="-]].. depth*1.2 ..[[" style="stroke:]]..AR_Outline..[[;stroke-width:1;opacity:]]..AR_Opacity..[[;" />
                                <line x1="-]].. depth*1.2 ..[[" y1="-]].. depth*1.2 ..[[" x2="-]]..tostring(depth*1.2 + 30)..[[" y2="-]].. depth*1.2 ..[[" style="stroke:]]..AR_Outline..[[;stroke-width:1;opacity:]]..AR_Opacity..[[;" />
                                <text x="-]]..tostring(6*#name+depth*1.2)..[[" y="-]].. depth*1.2+screenHeight*0.0035 ..[[" style="fill: ]]..AR_Outline..[[" font-size="]]..tostring(.04*AR_Size)..[[vw">]]..string.format('%s (%s)',name,pDistStr)..[[</text>
                                </g>]]
                    end
                end
            end
        end
        planetAR = planetAR .. '</svg>'
        -----------------------------------------------------------
        
        -- Shield widget if one is linked --
        if shield_1 ~= nil then
            local hp = shield_1.getShieldHitpoints()
            if shield_1.isVenting() == 0 and hp == 0 and autoVent then
                shield_1.startVenting()
            elseif shield_1.isActive() == 0 and shield_1.isVenting() == 0 then 
                shield_1.activate()
            end
            
            local arkTime = system.getArkTime()
            -- Shield Updates --
            local srp = shield_1.getResistancesPool()
            local csr = shield_1.getResistances()
            local rcd = shield_1.getResistancesCooldown()
            if shield_1.getStressRatioRaw()[1] == 0 and shield_1.getStressRatioRaw()[2] == 0 and shield_1.getStressRatioRaw()[3] == 0 and shield_1.getStressRatioRaw()[4] == 0 then
                dmgTick = 0
                srp = srp / 4
                if (csr[1] == srp and csr[2] == srp and csr[3] == srp and csr[4] == srp) or rcd ~= 0 then
                    --No change
                else
                    shield_1.setResistances(srp,srp,srp,srp)
                end
            elseif math.abs(arkTime - dmgTick) >= initialResistWait then
                local srr = shield_1.getStressRatioRaw()
                if (csr[1] == (srp*srr[1]) and csr[2] == (srp*srr[2]) and csr[3] == (srp*srr[3]) and csr[4] == (srp*srr[4])) or rcd ~= 0 then -- If ratio hasn't change, or timer is not up, don't waste the resistance change timer.
                    --No change
                else
                    shield_1.setResistances(srp*srr[1],srp*srr[2],srp*srr[3],srp*srr[4])
                end
            elseif dmgTick == 0 then
                dmgTick = arkTime
            end
        end
        
        -- Choose background color scheme based on PVP --
        bgColor = ''
        lineColor = ''
        if inSZ then bgColor=topHUDFillColorSZ lineColor=topHUDLineColorSZ textColor=textColorSZ 
        else bgColor=topHUDFillColorPVP lineColor=topHUDLineColorPVP textColor=textColorPVP
        end
        --------------------------------------------------
        
        -- Generate Screen overlay --
        if maxBrakeStr ~= nil then generateScreen() end
        -----------------------------
    onFlush:
      lua: |
        ---------- Global Values ----------
        local clamp  = utils.clamp
        local function signedRotationAngle(normal, vecA, vecB)
            vecA = vecA:project_on_plane(normal)
            vecB = vecB:project_on_plane(normal)
            return math.atan(vecA:cross(vecB):dot(normal), vecA:dot(vecB))
        end
        
        if (pitchPID == nil) then
            pitchPID = pid.new(0.1, 0, 10)
            rollPID = pid.new(0.1, 0, 10)
            yawPID = pid.new(0.1, 0, 10)
        end
        
        speedVec = vec3(construct.getWorldVelocity())
        speed = speedVec:len() * 3.6
        direction = speedVec
        if speed < 50 then direction = vec3(construct.getWorldOrientationForward()) end
        maxSpeed = construct.getMaxSpeed() * 3.6
        gravity = core.getGravityIntensity()
        mass = construct.getMass()
        constructPosition = vec3(construct.getWorldPosition())
        maxBrake = json.decode(unit.getWidgetData()).maxBrake
        local maxThrustTags = 'thrust'
        if #enabledEngineTags > 0 then
            maxThrustTags = maxThrustTags .. ' disengaged'
            for i,tag in pairs(enabledEngineTags) do
                maxThrustTags = maxThrustTags .. ',thrust '.. tag
            end
        end
        maxThrust = construct.getMaxThrustAlongAxis(maxThrustTags,construct.getOrientationForward())
        maxSpaceThrust = math.abs(maxThrust[3])
        local dockedMass = 0
        for _,id in pairs(construct.getDockedConstructs()) do 
            dockedMass = dockedMass + construct.getDockedConstructMass(id)
        end
        for _,id in pairs(construct.getPlayersOnBoard()) do 
            dockedMass = dockedMass + construct.getBoardedPlayerMass(id)
        end
        brakeDist,brakeTime = Kinematic.computeDistanceAndTime(speed/3.6,0,mass + dockedMass,0,0,maxBrake)
        accelVec = vec3(construct.getWorldAcceleration())
        accel = accelVec:len()
        
        speedStr = string.format('%.2f km/h',speed)
        gravityStr = string.format('%.2f G',gravity/9.81)
        if mass < 1000 then massStr = string.format('%.2f kg',mass)
        elseif mass < 1000000 then massStr = string.format('%.2f ton',mass/1000)
        else massStr = string.format('%.2f kton',mass/1000000)
        end
        maxBrakeStr = string.format('%.2f G',maxBrake/mass/9.81)
        maxThrustStr = string.format('%.2f G',maxSpaceThrust/mass/9.81)
        if brakeDist < 1000 then brakeDistStr = string.format('%.2f m',brakeDist)
        elseif brakeDist < 100000 then brakeDistStr = string.format('%.2f km',brakeDist/1000)
        else brakeDistStr = string.format('%.2f su',brakeDist*.000005)
        end
        accelStr = string.format('%.2f G',accel/9.81)
        maxSpeedStr = string.format('%.2f km/h',maxSpeed)
        ------------------------------------
        
        
        local pitchSpeedFactor = 0.8 --export: This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        local yawSpeedFactor =  1 --export: This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        local rollSpeedFactor = 1.5 --export: This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        
        local brakeSpeedFactor = 3 --export: When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01
        local brakeFlatFactor = 1 --export: When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        
        local autoRoll = false --export: [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)
        local autoRollFactor = 2 --export: [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01
        
        local turnAssist = true --export: [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is
        local turnAssistFactor = 2 --export: [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        
        local torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01
        
        -- validate params
        pitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)
        yawSpeedFactor = math.max(yawSpeedFactor, 0.01)
        rollSpeedFactor = math.max(rollSpeedFactor, 0.01)
        torqueFactor = math.max(torqueFactor, 0.01)
        brakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)
        brakeFlatFactor = math.max(brakeFlatFactor, 0.01)
        autoRollFactor = math.max(autoRollFactor, 0.01)
        turnAssistFactor = math.max(turnAssistFactor, 0.01)
        
        -- final inputs
        local finalPitchInput = pitchInput + system.getControlDeviceForwardInput()
        local finalRollInput = rollInput + system.getControlDeviceYawInput()
        local finalYawInput = yawInput - system.getControlDeviceLeftRightInput()
        local finalBrakeInput = brakeInput
        
        -- Axis
        local worldVertical = vec3(core.getWorldVertical()) -- along gravity
        local constructUp = vec3(construct.getWorldOrientationUp())
        local constructForward = vec3(construct.getWorldOrientationForward())
        local constructRight = vec3(construct.getWorldOrientationRight())
        local constructVelocity = vec3(construct.getWorldVelocity())
        local constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()
        local currentRollDeg = getRoll(worldVertical, constructForward, constructRight)
        local currentRollDegAbs = math.abs(currentRollDeg)
        local currentRollDegSign = utils.sign(currentRollDeg)
        
        -- Rotation
        local constructAngularVelocity = vec3(construct.getWorldAngularVelocity())
        -- SETUP AUTOPILOT ROTATIONS --
        local targetAngularVelocity = vec3()
        
        local destVec = vec3()
        local currentYaw = 0
        local currentPitch = 0
        local targetYaw = 0
        local targetPitch = 0
        local yawChange = 0
        local pitchChange = 0
        local totalAngularChange = nil
        if autopilot_dest then
            destVec = vec3(autopilot_dest - constructPosition)
            currentYaw = -math.deg(signedRotationAngle(constructUp, constructVelocity, constructForward))
            currentPitch = math.deg(signedRotationAngle(constructRight, constructVelocity, constructForward))
        
            targetYaw = -math.deg(signedRotationAngle(constructUp, destVec, constructForward))
            local targetPitch = math.deg(signedRotationAngle(constructRight, destVec, constructForward))
        
            yawChange = targetYaw-currentYaw
            pitchChange = targetPitch-currentPitch
            totalAngularChange = math.abs(yawChange) + math.abs(pitchChange)
            --system.print(string.format('%.2f | %.2f',pitchChange,yawChange))
        end
        
        if autopilot and autopilot_dest ~= nil and Nav.axisCommandManager:getThrottleCommand(0) ~= 0 then
            yawPID:inject(yawChange)
            local apYawInput = yawPID:get()
            if apYawInput > AP_Max_Rotation_Factor then apYawInput = AP_Max_Rotation_Factor
            elseif apYawInput < -AP_Max_Rotation_Factor then apYawInput = -AP_Max_Rotation_Factor
            end
        
            pitchPID:inject(pitchChange)
            local apPitchInput = -pitchPID:get()
            if apPitchInput > AP_Max_Rotation_Factor then apPitchInput = AP_Max_Rotation_Factor
            elseif apPitchInput < -AP_Max_Rotation_Factor then apPitchInput = -AP_Max_Rotation_Factor
            end
            targetAngularVelocity = apYawInput * 2 * constructUp
                                    + apPitchInput * 2 * constructRight
                                    + finalPitchInput * pitchSpeedFactor * constructRight
                                    + finalRollInput * rollSpeedFactor * constructForward
                                    + finalYawInput * yawSpeedFactor * constructUp
        else
            targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight
                + finalRollInput * rollSpeedFactor * constructForward
                + finalYawInput * yawSpeedFactor * constructUp
        end
        
        ---------------------------------
        
        -- In atmosphere?
        if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then
            local autoRollRollThreshold = 1.0
            -- autoRoll on AND currentRollDeg is big enough AND player is not rolling
            if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then
                local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit
                if (rollPID == nil) then
                    rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range
                end
                rollPID:inject(targetRollDeg - currentRollDeg)
                local autoRollInput = rollPID:get()
        
                targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward
            end
            local turnAssistRollThreshold = 20.0
            -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing
            if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then
                local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range
                local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range
        
                -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)
                local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180
                local rollVerticalRatio = 0
                if rescaleRollDegAbs < 90 then
                    rollVerticalRatio = rescaleRollDegAbs / 90
                elseif rescaleRollDegAbs < 180 then
                    rollVerticalRatio = (180 - rescaleRollDegAbs) / 90
                end
        
                rollVerticalRatio = rollVerticalRatio * rollVerticalRatio
        
                local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)
                local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio
        
                targetAngularVelocity = targetAngularVelocity
                                    + turnAssistPitchInput * constructRight
                                    + turnAssistYawInput * constructUp
            end
        end
        
        -- Engine commands
        local keepCollinearity = 1 -- for easier reading
        local dontKeepCollinearity = 0 -- for easier reading
        local tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities
        
        -- Rotation
        local angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)
        local airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())
        angularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction
        Nav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)
        
        -- Brakes
        local brakeAcceleration = vec3()
        if autopilot and autopilot_dest ~= nil and vec3(constructPosition - autopilot_dest):len() <= brakeDist + AP_Brake_Buffer then
            brakeAcceleration = -maxBrake * constructVelocityDir
        elseif autopilot and autopilot_dest ~= nil and not brakesOn then
            brakeAcceleration = vec3()
            brakeInput = 0
        else
            brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)
        end
        Nav:setEngineForceCommand('brake', brakeAcceleration)
        
        -- AutoNavigation regroups all the axis command by 'TargetSpeed'
        local autoNavigationEngineTags = ''
        local autoNavigationAcceleration = vec3()
        local autoNavigationUseBrake = false
        
        -- Longitudinal Translation
        local longitudinalEngineTags = 'thrust analog longitudinal'
        if #enabledEngineTags > 0 then
            longitudinalEngineTags = longitudinalEngineTags .. ' disengaged'
            for i,tag in pairs(enabledEngineTags) do
                longitudinalEngineTags = longitudinalEngineTags .. ',thrust analog longitudinal '.. tag
            end
        end
        local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
        local longitudinalAcceleration = vec3()
        
        if autopilot and autopilot_dest ~= nil and vec3(constructPosition - autopilot_dest):len() <= brakeDist + AP_Brake_Buffer then
            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,0)
            longitudinalAcceleration = vec3()
            Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
        elseif autopilot and autopilot_dest ~= nil and speed < maxSpeed - 10 and enginesOn then
            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,1)
            longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
            Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
        elseif autopilot and autopilot_dest ~= nil and speed >= maxSpeed - 10 then
            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,0)
            longitudinalAcceleration = vec3()
            Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
            enginesOn = false
        else
            if (longitudinalCommandType == axisCommandType.byThrottle) then
                longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)
                Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)
            elseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then
                local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)
                autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags
                autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration
                if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop
                    Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking
                then
                    autoNavigationUseBrake = true
                end
        
            end
        end
        
        -- Lateral Translation
        local lateralStrafeEngineTags = 'thrust analog lateral'
        local lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)
        if (lateralCommandType == axisCommandType.byThrottle) then
            local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)
            Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)
        elseif  (lateralCommandType == axisCommandType.byTargetSpeed) then
            local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)
            autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags
            autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration
        end
        
        -- Vertical Translation
        local verticalStrafeEngineTags = 'thrust analog vertical'
        local verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)
        if (verticalCommandType == axisCommandType.byThrottle) then
            local verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)
            Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, keepCollinearity, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)
        elseif  (verticalCommandType == axisCommandType.byTargetSpeed) then
            local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)
            autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags
            autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration
        end
        
        -- Auto Navigation (Cruise Control)
        if (autoNavigationAcceleration:len() > constants.epsilon) then
            if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward
            then
                autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'
            end
            Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)
        end
        
        -- Rockets
        Nav:setBoosterCommand('rocket_engine')
        
        -- Disable Auto-Pilot when destination is reached --
        if autopilot and autopilot_dest ~= nil and vec3(constructPosition - autopilot_dest):len() <= brakeDist + 100 + AP_Brake_Buffer and speed < 5 then
            system.print('-- Autopilot complete --')
            autopilot_dest_pos = nil
            autopilot = false
            brakeInput = brakeInput + 1
            Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,0)
            Nav:setEngineForceCommand(longitudinalEngineTags, vec3(), keepCollinearity)
        end
        ---------------------------------------------------
    onInputText(text):
      lua: |
        
        if string.starts(text,'disable ') then
            matches = {}
            for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
            if #matches == 2 then
                text = matches[2]
                local rem = false
                for i,tag in pairs(enabledEngineTags) do
                    if tag == text then rem = i break end
                end
                if rem then table.remove(enabledEngineTags,rem) system.print(string.format('-- Engine tag filter removed "%s"',text)) end
                if text == 'ALL' then enabledEngineTags = {} end
                if #enabledEngineTags == 0 then system.print('-- No tag filtering. All engines enabled --') end
            else
                system.print('-- "disable" command requries an engine tag --')
            end
        end
        if string.starts(text,'enable ') then
            matches = {}
            for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
            if #matches == 2 then
                text = matches[2]
                table.insert(enabledEngineTags,text)
                system.print(string.format('-- Engine tag filter added "%s" --',text))
                
                if text == 'ALL' then enabledEngineTags = {} end
            else
                system.print('-- "enable" command requries an engine tag --')
            end
        end
        if string.starts(text,'warp') then
            if string.starts(text,'warpFrom') then
                matches = {}
                for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
                if #matches == 3 then
                    dest = convertWaypoint(matches[3])
                    start = convertWaypoint(matches[2])
                else
                    system.print('Invalid entry')
                end
            elseif string.starts(text,'warp ') then
                start = nil
                matches = {}
                for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
                dest = convertWaypoint(matches[2])
            end
        
        
            -- Print out a designator to more easily tell
            -- multiple entries apart
            system.print('---------------------')
        
            -- Set initial minimum distance parameter to nil/empty
            local minDist = nil
            local pipeName = 'None'
        
            -- If we are entered both a start point and destination
            -- we will print out slightly different output
            if not start then
                curPos = vec3(construct.getWorldPosition())
                system.print('Selected Destination: ' .. text)
            else
                curPos = start
                system.print('Selected start position: ' .. matches[2])
                system.print('Selected Destination: ' .. matches[3])
            end
        
            -- Loop through all possible warp destinations.
            -- Determine each ones min distance from their
            -- line segment. If that distance is less than
            -- the global minimum, then we have found a new
            -- global minimum
            distType = ''
            for k,v in pairs(warp_beacons) do
                dist,tempType = pipeDist(curPos,v,dest,true)
                if dist ~= nil then
                    -- Once we know which one is the smallest, compare
                    -- it to our current smallest distance and see who
                    -- wins! If this one is smaller, we have a new
                    -- winner! Let's record the name and distance of the
                    -- new winner.
                    if not minDist or dist < minDist then
                        minDist = dist
                        pipeName = k
                        distType = tempType
                    end
                end
            end
        
            -- After we have checked all possible options, print out the final name
            -- and distance.
            system.print(string.format('Closest Warp %s: ',distType) .. pipeName)
            system.print(string.format('Closest Distance: %.2f SU',minDist*0.000005))
            system.print('---------------------')
        end
        if string.starts(text,'addWaypoint ') then
            matches = {}
            for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
            if #matches < 2 then
                system.print('-- Requires a position tag with the command --')
            elseif #matches > 3 then
                system.print('-- only a position tag and name can be given with the command --')
                system.print('-- addWaypoint <position tag> [name] --')
            else
                AR_Temp = true
                if #matches == 2 then
                    AR_Temp_Points['Temp_' .. tostring(#AR_Temp_Points)] = matches[2]
                    system.print(string.format('-- Added waypoint "%s" (%s) --','Temp_' .. tostring(#AR_Temp_Points),matches[2]))
                else
                    AR_Temp_Points[matches[3]] = matches[2]
                    system.print(string.format('-- Added waypoint "%s" (%s) --',matches[3],matches[2]))
                end
            end
        end
        if string.starts(text,'delWaypoint ') then
            matches = {}
            for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
            if #matches ~= 2 then
                system.print('-- Requires a waypoint name with the command --')
            else
                local rem = nil
                local count = 0
                for k,v in pairs(AR_Temp_Points) do
                    count = count + 1
                    if k == matches[2] then
                        rem = k
                    end
                end
                if rem then AR_Temp_Points[rem] = nil count = count -1 system.print(string.format('-- Removed waypoint "%s"',rem)) end
                if count == 0 then AR_Temp = false end
            end
        end
        if string.starts(text,'::pos{') then
            matches = {}
            for w in text:gmatch("([^ ]+) ?") do table.insert(matches,w) end
            autopilot_dest = vec3(convertWaypoint(matches[1]))
            autopilot_dest_pos = matches[1]
            system.print('-- Autopilot destination set --')
            system.print(matches[1])
        end

    onActionStart:
      args: ['antigravity']
      lua: |
          if antigrav ~= nil then antigrav.toggle() end
    onActionLoop:
      args: ['speeddown']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)
          end
    onActionStart:
      args: ['speeddown']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)
          end
    onActionLoop:
      args: ['speedup']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)
          end
    onActionStart:
      args: ['speedup']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)
          end
    onActionStart:
      args: ['stopengines']
      lua: |
          if Nav.axisCommandManager:getThrottleCommand(0) == 0 then
              Nav.axisCommandManager:setThrottleCommand(0,1)
              enginesOn = true
          else
              Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)
              enginesOn = false
          end
    onActionStart:
      args: ['lshift']
      lua: |
          lShift = true
    onActionStop:
      args: ['lshift']
      lua: |
          lShift = false
    onActionStart:
      args: ['booster']
      lua: |
          if player.isFrozen() == 1 then
              Nav:toggleBoosters()
          end
    onActionStart:
      args: ['brake']
      lua: |
          
          if brakeInput > 0 then
              brakeInput = 0
              brakesOn = false
          else
              brakeInput = brakeInput + 1
              brakesOn = true
          end
          
          local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)
          if (longitudinalCommandType == axisCommandType.byTargetSpeed) then
              local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)
              if (math.abs(targetSpeed) > constants.epsilon) then
                  Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))
              end
          end

    onActionStart:
      args: ['yawleft']
      lua: |
          if player.isFrozen() == 1 then
              yawInput = yawInput + 1
          end
    onActionStop:
      args: ['yawleft']
      lua: |
          if player.isFrozen() == 1 then
              yawInput = yawInput - 1
          end
    onActionStart:
      args: ['yawright']
      lua: |
          if player.isFrozen() == 1 then
              yawInput = yawInput - 1
          end
    onActionStop:
      args: ['yawright']
      lua: |
          if player.isFrozen() == 1 then
              yawInput = yawInput + 1
          end
    onActionLoop:
      args: ['groundaltitudedown']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)
          end
    onActionStart:
      args: ['groundaltitudedown']
      lua: |
          Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)
    onActionLoop:
      args: ['groundaltitudeup']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)
          end
    onActionStart:
      args: ['groundaltitudeup']
      lua: |
          Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)
    onActionStop:
      args: ['down']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)
              Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
          end
          

    onActionStart:
      args: ['down']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
              Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)
          end
          

    onActionStop:
      args: ['up']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)
              Nav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)
          end

    onActionStart:
      args: ['up']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()
              Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)
          end
          

    onActionStop:
      args: ['strafeleft']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)
          end
    onActionStart:
      args: ['strafeleft']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)
          end
    onActionStop:
      args: ['straferight']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)
          end
    onActionStart:
      args: ['straferight']
      lua: |
          if player.isFrozen() == 1 then
              Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)
          end
    onActionStop:
      args: ['right']
      lua: |
          if player.isFrozen() == 1 then
              rollInput = rollInput - 1
          end
    onActionStart:
      args: ['right']
      lua: |
          rollInput = rollInput + 1
    onActionStop:
      args: ['left']
      lua: |
          if player.isFrozen() == 1 then
              rollInput = rollInput + 1
          end
    onActionStart:
      args: ['left']
      lua: |
          if player.isFrozen() == 1 then
              rollInput = rollInput - 1
          end
    onActionStop:
      args: ['backward']
      lua: |
          if player.isFrozen() == 1 then
              pitchInput = pitchInput - 1
          end
    onActionStart:
      args: ['backward']
      lua: |
          if player.isFrozen() == 1 then
              pitchInput = pitchInput + 1
          end
    onActionStop:
      args: ['forward']
      lua: |
          if player.isFrozen() == 1 then
              pitchInput = pitchInput + 1
          end
    onActionStart:
      args: ['forward']
      lua: |
          if player.isFrozen() == 1 then
              pitchInput = pitchInput - 1
          end
    onActionStart:
      args: ['light']
      lua: |
          if Nav.control.isAnyHeadlightSwitchedOn() == 1 then
              Nav.control.switchOffHeadlights()
          else
              Nav.control.switchOnHeadlights()
          end
          

    onActionStart:
      args: ['gear']
      lua: |
          gearExtended = not gearExtended
          if gearExtended then
              Nav.control.deployLandingGears()
              Nav.axisCommandManager:setTargetGroundAltitude(0)
              system.freeze(0)
          else
              Nav.control.retractLandingGears()
              Nav.axisCommandManager:setTargetGroundAltitude(defaultHoverHeight)
              system.freeze(1)
          end
          


    onActionStart:
      args: ['option1']
      lua: |
          if showHelp then if not showHelper then system.showHelper(0) end showHelp = false else system.showHelper(1) showHelp = true end
    onActionStart:
      args: ['option2']
      lua: |
          if AR_Mode == 'ALL' then AR_Mode = 'PLANETS' system.print('-- AR Mode: Planets --')
          elseif AR_Mode == 'PLANETS' and AR_Temp then AR_Mode = 'TEMPORARY' system.print('-- AR Mode: TEMPORARY --')
          elseif AR_Mode == 'PLANETS' and AR_Custom then AR_Mode = 'FROM_FILE' system.print('-- AR Mode: FROM_FILE --')
          elseif AR_Mode == 'PLANETS' then AR_Mode = 'NONE' system.print('-- AR Mode: NONE --')
          elseif AR_Mode == 'TEMPORARY' and AR_Custom then AR_Mode = 'FROM_FILE' system.print('-- AR Mode: FROM_FILE --')
          elseif AR_Mode == 'TEMPORARY' then AR_Mode = 'NONE' system.print('-- AR Mode: NONE --')
          elseif AR_Mode == 'FROM_FILE' then AR_Mode = 'NONE' system.print('-- AR Mode: None --')
          elseif AR_Mode == 'NONE' then AR_Mode = 'ALL' system.print('-- AR Mode: All --')
          end
    onActionStart:
      args: ['option3']
      lua: |
          if lShift then
              local tag = nil
              for i,t in pairs(predefinedTags) do
                  if contains(enabledEngineTags,t) then
                      tag = i
                  end
              end
              if tag then
                  local rem = nil
                  for k,v in pairs(enabledEngineTags) do
                      if v == predefinedTags[tag] then
                          rem = k
                      end
                  end
                  if rem then
                      table.remove(enabledEngineTags,rem)
                  end
                  if tag < #predefinedTags then
                      table.insert(enabledEngineTags,predefinedTags[tag+1])
                      system.print(string.format('-- Engine tag filter changed "%s" to "%s"',predefinedTags[tag],predefinedTags[tag+1]))
                  else
                      system.print(string.format('-- All Engines Enabled --'))
                  end
              else
                  table.insert(enabledEngineTags,predefinedTags[1])
                  system.print(string.format('-- Engine tag filter added "%s"',predefinedTags[1]))
              end
          else
              enabledEngineTags = {}
              system.print('-- All Engines Enabled --')
          end
    onActionStart:
      args: ['option4']
      lua: |
          autopilot = not autopilot
          if autopilot and autopilot_dest == nil then
              autopilot = false
              system.print('-- No autopilot destination entered --')
              system.print('-- Autopilot disabled --')
          elseif not autopilot then
              system.print('-- Autopilot disabled --')
          end
          if autopilot then
              system.print('-- Autopilot engaged --')
              system.setWaypoint(autopilot_dest_pos)
              brakesOn = false
              enginesOn = true
          end
    onActionStart:
      args: ['option5']
      lua: |
          auto_follow = not auto_follow
          if not auto_follow then 
              followID = nil
              if (Nav.axisCommandManager:getAxisCommandType(0) ~= axisCommandType.byThrottle) then
                  Nav.control.cancelCurrentControlMasterMode()
              end
              Nav.axisCommandManager:setThrottleCommand(axisCommandId.longitudinal,0)
          end
          system.print(string.format('-- Auto Follow "%s"',auto_follow))
    onActionStart:
      args: ['option6']
      lua: |
          if inSZ then system.print('-- Already in Safe Zone --') end
          system.print(string.format('-- Nearest SZ Center: %s',nearestSZPOS))
          system.setWaypoint(nearestSZPOS)
          autopilot_dest = vec3(convertWaypoint(nearestSZPOS))

    onActionStart:
      args: ['option7']
      lua: |

    onActionStart:
      args: ['option8']
      lua: |

    onActionStart:
      args: ['option9']
      lua: |
          local masterMode = Nav.axisCommandManager:getMasterMode()
          if (masterMode == controlMasterModeId.travel) then
              Nav.control.cancelCurrentControlMasterMode()
              Nav.axisCommandManager:setMasterMode(controlMasterModeId.cruise)
          else
              Nav.control.cancelCurrentControlMasterMode()
              Nav.axisCommandManager:setMasterMode(controlMasterModeId.travel)
          end